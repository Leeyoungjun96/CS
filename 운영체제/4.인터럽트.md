## 인터럽트
* CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술  
  ex) 이벤트 발생 -(인터럽트)-> 처리 (code, kernel)


* 선점형 스케쥴러 구현
    * 프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체하기 위해, 현재 프로세스 실행을 중단시킴
        * 그러려면, 스케쥴러 코드가 실행이 되서, 현 프로세스 실행을 중지시켜야 함
* IO Device와 커뮤니케이션
    * 저장매체에서 데이터 처리 완료시, 프로세스를 깨워야 함 (block state -> ready state)
        * 파일 처리가 끝났다는 것을 운영체제에 알려주기
        * 운영체제는 해당 프로세스를 block state에서 실행 대기(ready) 상태로 프로세스 상태 변경하기
* 예외 상황 핸들링
    * CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우, CPU가 해댕 처리를 할 수 있도록 CPU에 알려줘야 함
        * 0으로 나누는 계산이 발생, 예외 발생을 운영체제에 알려주기
        * 운영체제가 해당 프로세스 실행 중지/에러 표시
* CPU는 PC(program counter)가 가르키는 코드 1줄에 집중하고 있음, 외부의 이벤트를 처리해야 될때, 정보를 어떻게 누가 알려줄것이냐를 운영체제 안에 구현함

* 주요 인터럽트(Interrupt)
  1. 계산하는 코드에서 0으로 나누는 코드 실행시 (Divide-by-Zero Interrupt)
*     int main()
      {
         printf("Hello World!\n");
         int data;
         int divider = 0;
         data = 1 / divider; // 이 부분에서 인터럽트 발생
         return 0;
      }
  2. 타이머 인터럽트
      * 선점형 스케쥴러를 위해 필요  
      컴퓨터 하드웨어 --(하드웨어로 부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려줌)--> 운영체제
  3. 입출력(I/O) 인터럽트
      * 프린터, 키보드, 마우스, 저장매체(SSD 등)


* 인터럽트 종류
  * 내부 인터럽트(소프트웨어 인터럽트)
    * 주로 프로그램 내부에서 잘못된 명령(예외상황) 또는 잘못된 데이터 사용시 발생
      * 0으로 나눴을 때
      * 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
        * 리눅스에서 프로세스는 4GB로 사용자 모드는 3GB, 커널모드는 1GB (이때 사용자모드가 아닌 커널모드로 접근하거나 그 반대일 때)
      * 계산 결과가 Overflow/Underflow 날 때
        * unsigned 부호 x, signed 부호 O(1bit) 이때 32bit를 사용하려고 하면 Overflow 반대로 마이너스 이상을 넘어갈때 Underflow
      * 외부 인터럽트(하드웨어 인터럽트)
      * 주로 하드웨어에서 발생되는 이벤트 (프로그램 외부)
      * 전원 이상
      * 기계 문제
      * 키보드등 IO 관련 이벤트
      * Timer 이벤트
      * 시스템 콜 인터럽트
      * 시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 함
      * 시스템콜 실제 코드
      * eax 레지스터에 시스템 콜 번호를 넣고,                   mov eax, 1->시스템콜 번호
      * ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,       mov ebx, 0->인자값
      * 소프트 웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌     int(CPU op code) 0x80 // 소프트웨어 인터럽트 명령, 여기서 int는 interrupt
      

      * 시스템콜 인터럽트 명령을 호출하면서 0x80값을 넘겨줌
          1. CPU는 사용자 모드를 커널 모드로 바꿔줌
          2. IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행
          3. system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
          4. 해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드 진행
      * 사용자 / 커널 모드와 프로세스, 인터럽트
        * User Mode     Process A->                   Process A->                   Process B
        * Kernel Mode             SystemCall Handler->           Process Scheduler->
                          System call                 Timer Interrupt(커널모드) -> proc A의 실행시간 만료


   * 인터럽트와 IDT
        * 인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있음
          * IDT(Interrupt Descriptor Table)에 기록 (이벤트 번호 : 실행코드의 주소 (함수)가 매핑)
          * 컴퓨터 부팅시 운영체제가 기록
          * 운영체제 내부코드 (커널모드/커널영역)
        * 항상 인터럽트 발생시 IDT를 확인
        * 시스템콜 인터럽트 명령은 0x80 번호가 미리 정의
        * 인터럽트 0x80에 해당하는 운영체제 코드는 system_call() 이라는 함수
        * IDT에는 0x80 -> system_call()와 같은 정보가 기록되어 있음
   * 인터럽트와 프로세스  
          5. 프로세스 실행 중 인터럽트 발생  
          6. 현 프로세스 실행 중단   
          7. 인터럽트 처리 함수 실행(운영체제)  
          8. 현 프로세스  

