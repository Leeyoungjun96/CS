# 가상메모리
#### 가상 메모리가 필요한 이유
* 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템 등)
  1. 프로그램을 메모리로 로드(load)
  2. 프로세스 실행
  3. 프로세스 종료(메모리 해제)
* 여러 프로세스 동시 실행 시스템
  1. 메모리 용량 부족 이슈
  2. 프로세스 메모리 영역간에 침범 이슈
#### 가상메모리 : 메모리가 실제 메모리보다 많아 보이게 하는 기술
  * 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  * 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
![virtual memory](../img/virtual_memory.PNG)
#### 가상 메모리 기본 아이디어
  * 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다
  * virtual address(가상 주소) : 프로세스가 참조하는 주소
  * physical address(물리 주소) : 실제 메모리 주소
#### MMU(Memory Management Unit)
  * CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
#### 가상 메모리와 MMU
  * CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
    * 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠
  ![vm_mmu](../img/vm_mmu.PNG)

#### 페이징 시스템(paging system)
* 페이징 개념
  * 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
  * 하드웨어 지원이 필요
    * ex) Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
  * 리눅스에서는 4KB로 paging 
  * 페이징 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용


  * 프로세스(4GB)의 PCB에 Page Table 구조체를 가르키는 주소가 들어 있음
  * Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있음
  ![vm_paging](../img/vm_paging.PNG)
  

* 페이징 시스템 구조
  * page 또는 page frame : 고정된 크기의 block(4KB)
  * paging system
    * 가상 주소 V = (p,d)
      * p : 가상 메모리 페이지
      * d : p 안에서 참조하는 위치
  ![paging_system_con](../img/paging_system_con.PNG)
  * ex) 페이지 크기가 4KB
    * 가상 주소의 0비트에서 11비트가 변위(d)를 나타내고
      * 12비트 이상이 페이지 번호가 될 수 있음
  * 프로세스가 4GB를 사용하는 이유 : 32bit 시스템에서의 2의 32제곱이 4GB
  ![virtual memory](../img/virtual_memory.PNG)

* 페이지 테이블(Page Table)
  * page table
    * 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
    * 가상주소 v = (p,d)라면
      * p : 페이지 번호
      * d : 페이지 처음부터 얼마 떨어진 위치인지
  * paging system 동작
    * 해당 프로세스에서 특정 가상 주소 엑세스를 하려면
      * 해당 프로세스의 page table에 해당 가상 주소가 포함된 page 번호가 있는지 확인
      * page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고(p`)
      * p` + d가 실제 물리주소가 됨

#### 페이징 시스템과 MMU(컴퓨터 구조)
* CPU는 가상 주소 접근시
  * MMU 하드웨어 장치를 통해 물리 메모리 접근
  ![mmu](../img/vm_mmu.PNG)
  * 프로세스 생성시, 페이지 테이블 정보 생성
    * PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
    * 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
    * CPU가 가상 주소 접근시, MMU가 페이지 테이블 base주소(CR3)를 접근해서, 물리 주소를 가져옴

#### 다중 단계 페이징 시스템
* 32bit 시스템에서 4KB 페이지를 위한 페이징 시스템은
  * 하위 12bit는 오프셋
  * 상위 20bit가 페이징 번호이므로, 2의 20제곱(1048576)개의 페이지가 필요함
* 페이징 정보를 단계를 나누어 생성
  * 필요없는 페이지는 생성하지 않으면, 공간 절약 가능
* 페이지 번호를 나타내는 bit를 구분해서, 단게를 나눔(리눅스는 3단계, 최근 4단계)
![multi_paging](../img/multi_paging.PNG)

* MMU와 TLB(컴퓨터 구조)
  * MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
  ![mmu_tlb](../img/mmu_tlb.PNG)
  * TLB(Translation Lookaside Buffer) : 페이지 정보 캐쉬
  ![tlb](../img/tlb.PNG)

#### 페이징 시스템과 공유 메모리
* 프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)
![share](../img/share.PNG)
* 물리 주소 데이터 변경시
  * 물리 주소에 데이터 수정 시도시, 물리 주소를 복사할 수 있음(copy-on-write)
![share2](../img/share2.JPG)

#### 요구 페이징 (Demand Paging)
* 프로세스의 모든 데이터를 메모리에 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재
  * 선행 페이징 (anticipatory paging 또는 prepaging)의 반대 개념 : 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
  * 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 (페이지 교체 알고리즘 필요)
#### 페이지 폴트 (Page Fault Interrupt)
* 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
* 운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림
![page_fault](../img/page_fault.png)
* 페이지 폴트가 자주 일어나면
  * 실행되기 전에, 해당 페이지를 물리 메모리에 올려야 함
    * 시간이 오래걸림
* 페이지 폴트가 안 일어나게 하려면
  * 향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨
    * 앞으로 있을 일을 예측해야 함

#### 페이지 교체 정책 (page replacement policy)
* 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 차 있을 때
  * 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장)
  * 새로운 페이지를 해당 물리 메모리 공간에 올림
  * 어떤 페이지를 물리 메모리에서 저장 매체로 내릴건가 -> Page Replacement(Swapping) Algorithm

* 페이지 교체 알고리즘 (FIFO)
  * FiFO Page Replacement Algorithm
    * 가장 먼저 들어온 페이지를 내리자
* 페이지 교체 알고리즘 (OPT)
  * 최적 페이지 교체 알고리즘 (OPTimal Replcaement Algorithm)
    * 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자
    * 예측기반이기 때문에 구현이 불가
* 페이지 교체 알고리즘 (LRU)
  * LRU(Least Recently Used) Page Replacement Algorithm
    * 가장 오래 전에 사용된 페이지를 내림
    * OPT 교체 알고리즘이 구현이 불가하므로, 과거 기록을 기반으로 시도
* 페이지 스왑 알고리즘 (LFU)
  * LFU(Least Frequently Used) Page Replacement Algorithm
    * 가장 적게 사용한 페이지를 교체
* 페이지 스왑 알고리즘 (NUR)
  * NUR(Not Used Recently) Page Replacement Algorithm
    * LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
    * 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R,M)
      * (0,0), (0,1), (1,0), (1,1) 순으로 교체
* 스레싱(Thrashing)
  * 반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황
  ![thrashing](../img/thrashing.png)

#### 세그멘테이션 기법
* 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할
  * 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할
  * ex) x86 real mode (호환 모드, 부팅시 CPU가 리얼모드)
    * CS(Code Segment), DS(Data Segement), SS(Stack Segment), EX(Extra Segment)로 세그먼트를 나누어, 메모리 접근
* 세그먼트 가상주소
  * v = (s,d) : s는 세그먼트 번호, d는 블록 내 세그먼트 범위
![segment](../img/segment.png)
* 세그멘테이션은 크기가 다른 segment 단위로 물리 메모리에 로딩
![segment2](../img/segment2.png)

* 내부 단편화(페이지 기법)
  * 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비
* 외부 단편화(세그멘테이션 기법)
  * 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우
* 세그멘테이션/페이징 모두 하드웨어 지원 필요
  * 다양한 컴퓨터 시스템에 이식성을 중요시하는 리눅스는 페이징 기법을 기반으로 구현